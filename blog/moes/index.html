<!doctype html><html lang=en dir=auto><head><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Switch Transformer - Sparse Routed Networks/MoEs | Srishti Gureja</title>
<meta name=keywords content="NLP,PyTorch"><meta name=description content="In this short post, I am going to talk about the Switch Transformer paper.
Background and Architecture To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.
Hence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters => more computation performed by a single token. And tangential to this, work by Kaplan et al."><meta name=author content><link rel=canonical href=https://srishti-git1110.github.io/blog/moes/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://srishti-git1110.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://srishti-git1110.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://srishti-git1110.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://srishti-git1110.github.io/apple-touch-icon.png><link rel=mask-icon href=https://srishti-git1110.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://srishti-git1110.github.io/blog/moes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Switch Transformer - Sparse Routed Networks/MoEs"><meta property="og:description" content="In this short post, I am going to talk about the Switch Transformer paper.
Background and Architecture To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.
Hence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters => more computation performed by a single token. And tangential to this, work by Kaplan et al."><meta property="og:type" content="article"><meta property="og:url" content="https://srishti-git1110.github.io/blog/moes/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-06-17T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-17T00:00:00+00:00"><meta property="og:site_name" content="Srishti Gureja"><meta name=twitter:card content="summary"><meta name=twitter:title content="Switch Transformer - Sparse Routed Networks/MoEs"><meta name=twitter:description content="In this short post, I am going to talk about the Switch Transformer paper.
Background and Architecture To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.
Hence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters => more computation performed by a single token. And tangential to this, work by Kaplan et al."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://srishti-git1110.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Switch Transformer - Sparse Routed Networks/MoEs","item":"https://srishti-git1110.github.io/blog/moes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Switch Transformer - Sparse Routed Networks/MoEs","name":"Switch Transformer - Sparse Routed Networks\/MoEs","description":"In this short post, I am going to talk about the Switch Transformer paper.\nBackground and Architecture To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.\nHence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters =\u0026gt; more computation performed by a single token. And tangential to this, work by Kaplan et al.","keywords":["NLP, PyTorch"],"articleBody":"In this short post, I am going to talk about the Switch Transformer paper.\nBackground and Architecture To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.\nHence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters =\u003e more computation performed by a single token. And tangential to this, work by Kaplan et al. (2020) becomes super relevant as they discuss training larger models on comparatively smaller amounts of data as the computationally optimal approach.\nSo, the point is that while increasing the number of model parameters yields performance, it comes at the cost of increased total computation/FLOPs per token (There’s nuance to the former part of this statement but it communicates the gist).\nSuch is not the case with Routed Models as we’ll see. Let’s first look at what a “Routed Layer” looks like. The above figure might seem intimidating but we’ll understand all of it. The single feed forward layer is replaced by several different FF layers (FF1 through FF4 in the figure) each of which is called an Expert. Each token is routed to only one of the experts during a single forward pass. The Router (in green) is yet another FFNN that decides which expert should each token be routed to. And to make it clear, the same router is used for all tokens.\nLet’s look at some math Consider,\n\\( \\mathcal{B} \\): the current batch \\( T \\): number of tokens in the current batch \\( N \\): the number of experts in the current routed layer \\( E_i \\): the expert \\( i \\) \\( p_i(x) \\): the probability that the token \\( x \\) is routed to \\( E_i \\) The Router, as discussed, is a FFNN that takes \\( x \\) as an input and first produces logits given by: $$ h(x) = W_r . x $$\nwhere,\n\\( W_r \\): The router weights\nTalk of probability in FFNNs and you have softmax; hence the router probability for a particular expert \\( E_i \\) is calculated by normalizing the logits as:\n$$ p_i(x) = \\frac{e^{h(x)_i}}{\\sum_{j=1}^{N} e^{h(x)_j}} $$\nFrom here, as can be seen in the figure above, the Switch paper routes \\( x \\) to the expert with the highest \\( p_i(x) \\).\nAnd thereupon the output corresponding to token \\( x \\) is calculated as:\n$$ y = p_i(x)E_i(x); i \\in {1, 2, …, N} $$\nThis is what the dotted line in the figure shows.\nTo revise: we went from a layer with a single feed forward network to what the paper calls a “Switch layer”.\nWhat happened here? The architectural change was straight forward to understand: you replace the single FF network with a bunch of different FF networks, of which one token uses only one at a time. What this means is that while the total parameters in the layer increase this way by \\( N \\) times, the total computation performed by each token remained constant.\nAnd so here we go: We are able to scale on the number-of-parameters axis while keeping the FLOPs per token constant. All of this by virtue of the routing mechanism that introduces “sparsity” in the model – not all parameters of the model are activated during a token’s forward pass.\nRevising the Switch Layer: MoE vs Switch Transformer As we saw above, one token is routed to only one expert at a time in the Switch Transformer paper.\nThe Outrageously Large Neural Networks paper (Shazeer et al. 2017) does this differently. Instead of routing a token to only one expert, they select the top-k experts for a token, in which case the output of the MoE layer (they call it that) for that token becomes:\n$$ y = \\sum_{i \\in \\mathcal{T}} p_i(x)E_i(x) $$\nwhere,\n\\( \\mathcal{T} \\): set of top-k Experts\nWhy top-k? I read the OLNN paper carefully but did not see any elaborate mentions of why \\( k\u003e1 \\) experts are required. But what the paper nicely elaborates on is “load-balancing”. We’ll circle back to load-balancing in context of the Switch paper but the term essentially means to ensure that all experts are sufficiently utilized and hence trained during the training process. In other words, the router shouldn’t always favour a certain (set of) expert(s).\nAnd from here, one can intuition about why the authors chose \\( k\u003e1 \\) (precisely they use \\( k=4 \\)) – to make sure that not just one but more than one expert is involved during any single backprop for the router to be able learn the routing process without favouring a single (set of) expert(s).\nThat said, if \\( k\u003e1 \\) is one aspect of load-balancing along with playing a part in making sure all experts are sufficiently trained, how were the Switch authors able to do well without it?\nAuxiliary loss This section is the answer to that. The aux loss is just a term that’s added to the total model loss. The purpose of it is to penalize the router for favouring a certain expert too much, i.e. for giving too large a probability to any one expert. Hence, this loss encourages a “uniform routing”. The word “uniform” here is more than an english word; it’s used in the statistical sense of the Uniform Distribution and logically so. Because what we want is for the tokens to be distributed uniformly among the experts.\nAnd we will see how exactly does this loss encourages a Uniform Distribution. But let’s see the math once.\nKeeping the previous notations same, consider:\n\\( f_i \\): the fraction of tokens routed to \\( E_i \\) Hence,\n\\( f_i \\) = Number of tokens from \\( \\mathcal{B} \\) router to \\( E_i \\) / Total tokens in \\( \\mathcal{B} \\)\n$$ f_i = \\frac{1}{T} \\sum_{x \\in \\mathcal{B}} \\mathbb{1} \\{argmax \\ p(x) = i \\} $$\n\\( P_i \\): fraction of the router probability assigned to \\( E_i \\) across all tokens in \\( \\mathcal{B} \\) Hence,\n\\( P_i \\) = Sum of \\( p_i(x) \\) across \\( \\mathcal{B} \\) / Total router probability across \\( \\mathcal{B} \\)\n$$ P_i = \\frac{1}{T} \\sum_{x \\in \\mathcal{B}} p_i(x) $$\nThe aux loss is now given by:\n$$ loss = \\alpha . N . \\sum_{i=1}^{N} f_i . P_i $$\nwhere,\n\\( \\alpha \\): coefficient to control the effect of aux losses It needs to be large enough for the aux losses to have a sufficient load-balancing effect, and small enough to not overwhelm the primary modelling loss.\nNow, under Uniform routing (which is what we want), each expert should get \\( \\frac{T}{N} \\) tokens routed to it. And for every particular \\( x \\), \\( p_i(x) \\) should be \\( \\frac{1}{N} \\) for each value of \\( i \\) i.e. for each expert.\nHence, under uniform routing:\n$$ f_i = \\frac{1}{T} x \\frac{T}{N} = \\frac{1}{N} $$ $$ P_i = \\frac{1}{T} x \\sum_{x \\in \\mathcal{B}} \\frac{1}{N} = \\frac{1}{T} x \\frac{T}{N} = \\frac{1}{N} $$\nAnd these are the exact values at which the aux loss as described above is minimized, and hence it encourages uniform routing!\n[Notice the term \\( N \\) multiplied in the aux loss equation? Plug in these uniform values and try to reason why it’s necessary.]\nObviously, there’s more than a single switch layer in the full architecture, and we want each one of it to route uniformly. So, aux losses corresponding to each switch layer are calculated and added to the language model training loss.\nBenefits of \\( k=1 \\) (The Switch Layer) Choosing \\( k=1 \\) over \\( k\u003e1 \\) results in some obvious benefits:\nLess computation needs to be performed per token. Cross device communication is reduced owing to the needlessness to perform an addition operation to be able to get the token output. Efficient routing: Expert Capacity The Expert Capacity of each expert which is basically the max batch size allocated to each expert. It goes:\n$$ \\text{expert capacity} = \\left( \\frac{\\text{tokens per batch}}{\\text{number of experts}} \\right) \\times \\text{capacity factor} $$\nAs is clear, the capacity factor is introduced in the above equation to create an additional buffer for cases when there’s an unequal allocation of tokens among the experts by the router. If the router allocated count exceeds the Expert Capacity, the extra tokens are just dropped from the expert computation (and make their way to the next layer via the residual connection).\nNow a natural question is that why is this additional constraint even required and why can’t we just have the router route however it wants with the flexibility to increase the Expert Capacity indefinitely? At once, load balancing might come up as one reason but if thought carefully, Expert Capacity doesn’t really do anything in that sense. As in it’s not encouraging balancing in the sense of causing other experts to be equally utilized simply because the extra tokens are just dropped and not like re-routed to some other expert(s).\nThe reason why Expert Capacity is needed is to make sure that resources (computation and memory) are not wasted while some expert operates at its full capacity and others don’t; and obviously this is also the reason why we don’t want to have too large of an expert capacity. The goal is to strike a good balance so that not many tokens are dropped (the authors empirically prove that a lower drop rate is important to scale these models) and not a lot of resources are wasted.\n[I realise that this reasoning might still remain a bit unclear or atleast too abstract to grasp to those that don’t have a clear understanding of the GPU arch, resource management, memory allocation on the devices etc. The insight here is that if the expert capacity of each expert is set to very high, it will be a waste for those experts that do not process as many tokens. GPUs are expensive and we don’t want resources to be idle.]\nScaling Laws There are a couple interesting plots in the paper showing scaling on the number-of-experts axis. Note that increasing the number of experts does not increase the FLOPs per token and hence the models remain FLOPs matched – the computation budget per token remains constant.\nMore experts = Better test loss The plot below clearly shows that as the number of experts increase the test loss decreases. Ofcourse, everything else (#tokens, #training steps etc.) must be kept constant. More experts = Fast training Firstly, fast here does not mean more examples processed per second. Fast implies what can be clearly seen in the plot below: Having more experts achieves the same level of negative log perplexity faster than a model with lesser experts – faster in terms of the number of training steps performed. Additionally, the authors also find for a fixed number of tokens seen, larger models learn faster.\nWhat needs to be carefully noted here is that while the total computation performed per token (FLOPs per token) is constant across models with varying number of experts, a relatively very small computation difference is there by virtue of the router having to compute as many probailities as there are the number of experts; but this is minor. Consequently, we also note that there’s no router calculations at all in dense models. And additionally, Switch transformer also needs to do some extra communication across devices by virtue of the different experts being on different devices.\nThis leads us to an important point: Being faster on the numnber-of-training steps axis does not necessarily mean being faster on the time-taken-by-the-wall-clock axis. Again, the premise here is that the Switch Transformer, owing to the extra computation and communication that it needs to do, might complete a certain number of training steps slower than its dense counterpart. This means that while we expect the Switch Transformer to be better performing after completing the same number of training steps as the dense model, it can still take more time for the former to actually reach that point.\nSo the next obvious question is: Given a fixed amount of wall clock time (and ofcourse the computation budget), how do these models compare in performance with each other?\nFixed training time The plot below answers the question posed just above - For a fixed training duration, Switch transformer outperforms the dense model. Same story for the number of experts as they grow, but here the difference isn’t as significant and the intuition is pretty easy to reach at if the past few paras were clear enough. Moving forward to FLOPs un-matched If we go back to the motivation behind using a MoE or a sparse routed model like the Switch Transformer, it’s simply stated as: MoEs allow us to increase the parameter count while keeping the computational budget constant. While the benefit of training an MoE/Switch model over its FLOPs matched baseline is clear by now, how does a Switch model compare with a more-FLOPs-demanding dense baseline? The plot below shows that Switch-Base (124B FLOPs/seq) is still more sample efficient than dense T5-Large (425B FLOPs/seq). This is cool!\nLet’s “infer” the tradeoff! Now, let’s “infer” a tradeoff from whatever we’ve studied till now. I am using those quotes because the tradeoff is regarding the Inference stage. :-)\nThe obvious reason being that all the experts need to be loaded As we’ve seen, with the same amount of computational budget, MoE/Switch performs better than the FLOPs matched dense baseline owing to ofcourse, the greater number of parameters that it has. What this also means for the inference stage is that the former requires more memory than the latter in exchange of the performance gains that it offers. The obvious reason being that all the experts need to be loaded in the memory.\nHence, it’s a memory vs performance tradeoff.\nReferences [1] Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity\n[2] Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer\n","wordCount":"2330","inLanguage":"en","datePublished":"2024-06-17T00:00:00Z","dateModified":"2024-06-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://srishti-git1110.github.io/blog/moes/"},"publisher":{"@type":"Organization","name":"Srishti Gureja","logo":{"@type":"ImageObject","url":"https://srishti-git1110.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://srishti-git1110.github.io/ accesskey=h title="Srishti Gureja (Alt + H)">Srishti Gureja</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://srishti-git1110.github.io/about/ title=about><span>about</span></a></li><li><a href=https://srishti-git1110.github.io/code/ title=code><span>code</span></a></li><li><a href=https://srishti-git1110.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://srishti-git1110.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://srishti-git1110.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://srishti-git1110.github.io/blog/>Blogs</a></div><h1 class="post-title entry-hint-parent">Switch Transformer - Sparse Routed Networks/MoEs</h1><div class=post-meta><span title='2024-06-17 00:00:00 +0000 UTC'>June 17, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#background-and-architecture>Background and Architecture</a><ul><li><a href=#lets-look-at-some-math>Let&rsquo;s look at some math</a></li></ul></li><li><a href=#what-happened-here>What happened here?</a></li><li><a href=#revising-the-switch-layer-moe-vs-switch-transformer>Revising the Switch Layer: MoE vs Switch Transformer</a><ul><li><a href=#why-top-k>Why top-k?</a></li></ul></li><li><a href=#auxiliary-loss>Auxiliary loss</a><ul><li><a href=#benefits-of--k1--the-switch-layer>Benefits of \( k=1 \) (The Switch Layer)</a></li></ul></li><li><a href=#efficient-routing-expert-capacity>Efficient routing: Expert Capacity</a></li><li><a href=#scaling-laws>Scaling Laws</a></li><li><a href=#lets-infer-the-tradeoff>Let&rsquo;s &ldquo;infer&rdquo; the tradeoff!</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>In this short post, I am going to talk about the Switch Transformer paper.</p><h2 id=background-and-architecture>Background and Architecture<a hidden class=anchor aria-hidden=true href=#background-and-architecture>#</a></h2><p>To begin: In Dense Models, each parameter/neuron of the network gets activated during the forward pass.</p><p><img loading=lazy src=ffnn.png#center alt="fully activated dense model"></p><p>Hence, to be able to derive more performance by means of increasing the model size, more computation is required. Implicitly, more model parameters => more computation performed by a single token.
And tangential to this, work by <a href=https://arxiv.org/abs/2001.08361>Kaplan et al. (2020)</a> becomes super relevant as they discuss training larger models on comparatively smaller amounts of data as the computationally optimal approach.</p><p>So, the point is that while increasing the number of model parameters yields performance, it comes at the cost of increased total computation/FLOPs per token (There&rsquo;s nuance to the former part of this statement but it communicates the gist).</p><p>Such is not the case with Routed Models as we&rsquo;ll see. Let&rsquo;s first look at what a &ldquo;Routed Layer&rdquo; looks like.
<img loading=lazy src=switch.png alt="Routed models"></p><p>The above figure might seem intimidating but we&rsquo;ll understand all of it.
The single feed forward layer is replaced by several <em>different</em> FF layers (FF1 through FF4 in the figure) each of which is called an <em>Expert</em>. Each token is routed to only one of the experts during a single forward pass. The Router (in green) is yet another FFNN that decides which expert should each token be routed to. And to make it clear, the same router is used for all tokens.</p><h3 id=lets-look-at-some-math>Let&rsquo;s look at some math<a hidden class=anchor aria-hidden=true href=#lets-look-at-some-math>#</a></h3><p>Consider,</p><ul><li>\( \mathcal{B} \): the current batch</li><li>\( T \): number of tokens in the current batch</li><li>\( N \): the number of experts in the current routed layer</li><li>\( E_i \): the expert \( i \)</li><li>\( p_i(x) \): the probability that the token \( x \) is routed to \( E_i \)</li></ul><p>The Router, as discussed, is a FFNN that takes \( x \) as an input and first produces logits given by:
$$ h(x) = W_r . x $$</p><p>where,</p><p>\( W_r \): The router weights</p><p>Talk of probability in FFNNs and you have softmax; hence the router probability for a particular expert \( E_i \) is calculated by normalizing the logits as:</p><p>$$ p_i(x) = \frac{e^{h(x)_i}}{\sum_{j=1}^{N} e^{h(x)_j}} $$</p><p>From here, as can be seen in the figure above, the Switch paper routes \( x \) to the expert with the highest \( p_i(x) \).</p><p>And thereupon the output corresponding to token \( x \) is calculated as:</p><p>$$ y = p_i(x)E_i(x); i \in {1, 2, &mldr;, N} $$</p><p>This is what the dotted line in the figure shows.</p><p>To revise: we went from a layer with a single feed forward network to what the paper calls a &ldquo;Switch layer&rdquo;.</p><h2 id=what-happened-here>What happened here?<a hidden class=anchor aria-hidden=true href=#what-happened-here>#</a></h2><p>The architectural change was straight forward to understand: you replace the single FF network with a bunch of different FF networks, of which one token uses only one at a time. What this means is that while the total parameters in the layer increase this way by \( N \) times, the total computation performed by each token remained constant.</p><p>And so here we go: We are able to scale on the number-of-parameters axis while keeping the FLOPs per token constant. All of this by virtue of the routing mechanism that introduces &ldquo;sparsity&rdquo; in the model &ndash; not all parameters of the model are activated during a token&rsquo;s forward pass.</p><h2 id=revising-the-switch-layer-moe-vs-switch-transformer>Revising the Switch Layer: MoE vs Switch Transformer<a hidden class=anchor aria-hidden=true href=#revising-the-switch-layer-moe-vs-switch-transformer>#</a></h2><p>As we saw above, one token is routed to only one expert at a time in the Switch Transformer paper.</p><p>The Outrageously Large Neural Networks paper (Shazeer et al. 2017) does this differently. Instead of routing a token to only one expert, they select the top-k experts for a token, in which case the output of the MoE layer (they call it that) for that token becomes:</p><p>$$ y = \sum_{i \in \mathcal{T}} p_i(x)E_i(x) $$</p><p>where,</p><p>\( \mathcal{T} \): set of top-k Experts</p><h3 id=why-top-k>Why top-k?<a hidden class=anchor aria-hidden=true href=#why-top-k>#</a></h3><p>I read the OLNN paper carefully but did not see any elaborate mentions of why \( k>1 \) experts are required. But what the paper nicely elaborates on is &ldquo;load-balancing&rdquo;. We&rsquo;ll circle back to load-balancing in context of the Switch paper but the term essentially means to ensure that all experts are sufficiently utilized and hence trained during the training process. In other words, the router shouldn&rsquo;t always favour a certain (set of) expert(s).</p><p>And from here, one can intuition about why the authors chose \( k>1 \) (precisely they use \( k=4 \)) &ndash; to make sure that not just one but more than one expert is involved during any single backprop for the router to be able learn the routing process without favouring a single (set of) expert(s).</p><p>That said, if \( k>1 \) is one aspect of load-balancing along with playing a part in making sure all experts are sufficiently trained, how were the Switch authors able to do well without it?</p><h2 id=auxiliary-loss>Auxiliary loss<a hidden class=anchor aria-hidden=true href=#auxiliary-loss>#</a></h2><p>This section is the answer to that.
The aux loss is just a term that&rsquo;s added to the total model loss. The purpose of it is to penalize the router for favouring a certain expert too much, i.e. for giving too large a probability to any one expert. Hence, this loss encourages a &ldquo;uniform routing&rdquo;. The word &ldquo;uniform&rdquo; here is more than an english word; it&rsquo;s used in the statistical sense of the Uniform Distribution and logically so. Because what we want is for the tokens to be distributed uniformly among the experts.</p><p>And we will see how exactly does this loss encourages a Uniform Distribution. But let&rsquo;s see the math once.</p><p>Keeping the previous notations same, consider:</p><ul><li>\( f_i \): the fraction of tokens routed to \( E_i \)</li></ul><p>Hence,</p><p>\( f_i \) = Number of tokens from \( \mathcal{B} \) router to \( E_i \) / Total tokens in \( \mathcal{B} \)</p><p>$$ f_i = \frac{1}{T} \sum_{x \in \mathcal{B}} \mathbb{1} \{argmax \ p(x) = i \} $$</p><ul><li>\( P_i \): fraction of the router probability assigned to \( E_i \) across all tokens in \( \mathcal{B} \)</li></ul><p>Hence,</p><p>\( P_i \) = Sum of \( p_i(x) \) across \( \mathcal{B} \) / Total router probability across \( \mathcal{B} \)</p><p>$$ P_i = \frac{1}{T} \sum_{x \in \mathcal{B}} p_i(x) $$</p><p>The aux loss is now given by:</p><p>$$ loss = \alpha . N . \sum_{i=1}^{N} f_i . P_i $$</p><p>where,</p><p>\( \alpha \): coefficient to control the effect of aux losses
It needs to be large enough for the aux losses to have a sufficient load-balancing effect, and small enough to not overwhelm the primary modelling loss.</p><p>Now, under Uniform routing (which is what we want), each expert should get \( \frac{T}{N} \) tokens routed to it. And for every particular \( x \), \( p_i(x) \) should be \( \frac{1}{N} \) for each value of \( i \) i.e. for each expert.</p><p>Hence, under uniform routing:</p><p>$$ f_i = \frac{1}{T} x \frac{T}{N} = \frac{1}{N} $$
$$ P_i = \frac{1}{T} x \sum_{x \in \mathcal{B}} \frac{1}{N} = \frac{1}{T} x \frac{T}{N} = \frac{1}{N} $$</p><p>And these are the exact values at which the aux loss as described above is minimized, and hence it encourages uniform routing!</p><p>[Notice the term \( N \) multiplied in the aux loss equation? Plug in these uniform values and try to reason why it&rsquo;s necessary.]</p><p>Obviously, there&rsquo;s more than a single switch layer in the full architecture, and we want each one of it to route uniformly. So, aux losses corresponding to each switch layer are calculated and added to the language model training loss.</p><h3 id=benefits-of--k1--the-switch-layer>Benefits of \( k=1 \) (The Switch Layer)<a hidden class=anchor aria-hidden=true href=#benefits-of--k1--the-switch-layer>#</a></h3><p>Choosing \( k=1 \) over \( k>1 \) results in some obvious benefits:</p><ol><li>Less computation needs to be performed per token.</li><li>Cross device communication is reduced owing to the needlessness to perform an addition operation to be able to get the token output.</li></ol><h2 id=efficient-routing-expert-capacity>Efficient routing: Expert Capacity<a hidden class=anchor aria-hidden=true href=#efficient-routing-expert-capacity>#</a></h2><p>The Expert Capacity of each expert which is basically the max batch size allocated to each expert. It goes:</p><p>$$ \text{expert capacity} = \left( \frac{\text{tokens per batch}}{\text{number of experts}} \right) \times \text{capacity factor} $$</p><p>As is clear, the capacity factor is introduced in the above equation to create an additional buffer for cases when there&rsquo;s an unequal allocation of tokens among the experts by the router. If the router allocated count exceeds the Expert Capacity, the extra tokens are just dropped from the expert computation (and make their way to the next layer via the residual connection).</p><p>Now a natural question is that why is this additional constraint even required and why can&rsquo;t we just have the router route however it wants with the flexibility to increase the Expert Capacity indefinitely? At once, load balancing might come up as one reason but if thought carefully, Expert Capacity doesn&rsquo;t really do anything in that sense. As in it&rsquo;s not encouraging balancing in the sense of causing other experts to be equally utilized simply because the extra tokens are just dropped and not like re-routed to some other expert(s).</p><p>The reason why Expert Capacity is needed is to make sure that resources (computation and memory) are not wasted while some expert operates at its full capacity and others don&rsquo;t; and obviously this is also the reason why we don&rsquo;t want to have too large of an expert capacity. The goal is to strike a good balance so that not many tokens are dropped (the authors empirically prove that a lower drop rate is important to scale these models) and not a lot of resources are wasted.</p><p>[I realise that this reasoning might still remain a bit unclear or atleast too abstract to grasp to those that don&rsquo;t have a clear understanding of the GPU arch, resource management, memory allocation on the devices etc. The insight here is that if the expert capacity of each expert is set to very high, it will be a waste for those experts that do not process as many tokens. GPUs are expensive and we don&rsquo;t want resources to be idle.]</p><h2 id=scaling-laws>Scaling Laws<a hidden class=anchor aria-hidden=true href=#scaling-laws>#</a></h2><p>There are a couple interesting plots in the paper showing scaling on the number-of-experts axis.
Note that increasing the number of experts does not increase the FLOPs per token and hence the models remain <em>FLOPs matched</em> &ndash; the computation budget per token remains constant.</p><ol><li>More experts = Better test loss
The plot below clearly shows that as the number of experts increase the test loss decreases. Ofcourse, everything else (#tokens, #training steps etc.) must be kept constant.</li></ol><p><img loading=lazy src=sl1.png alt=sl1></p><ol start=2><li>More experts = Fast training
Firstly, fast here does not mean more examples processed per second.
Fast implies what can be clearly seen in the plot below: Having more experts achieves the same level of negative log perplexity faster than a model with lesser experts &ndash; faster in terms of the number of training steps performed.</li></ol><p><img loading=lazy src=sl2.png alt=sl2></p><p>Additionally, the authors also find for a fixed number of tokens seen, larger models learn faster.</p><p>What needs to be carefully noted here is that while the total computation performed per token (FLOPs per token) is constant across models with varying number of experts, a relatively very small computation difference is there by virtue of the router having to compute as many probailities as there are the number of experts; but this is minor.
Consequently, we also note that there&rsquo;s no router calculations at all in dense models. And additionally, Switch transformer also needs to do some extra communication across devices by virtue of the different experts being on different devices.</p><p>This leads us to an important point: Being faster on the numnber-of-training steps axis does not necessarily mean being faster on the time-taken-by-the-wall-clock axis. Again, the premise here is that the Switch Transformer, owing to the extra computation and communication that it needs to do, might complete a certain number of training steps slower than its dense counterpart.
This means that while we expect the Switch Transformer to be better performing after completing the same number of training steps as the dense model, it can still take more time for the former to actually reach that point.</p><p>So the next obvious question is: Given a fixed amount of wall clock time (and ofcourse the computation budget), how do these models compare in performance with each other?</p><ol start=3><li>Fixed training time
The plot below answers the question posed just above - For a fixed training duration, Switch transformer outperforms the dense model. Same story for the number of experts as they grow, but here the difference isn&rsquo;t as significant and the intuition is pretty easy to reach at if the past few paras were clear enough.</li></ol><p><img loading=lazy src=sl3.png alt=sl3></p><ol start=4><li>Moving forward to <em>FLOPs un-matched</em>
If we go back to the motivation behind using a MoE or a sparse routed model like the Switch Transformer, it&rsquo;s simply stated as: MoEs allow us to increase the parameter count while keeping the computational budget constant.</li></ol><p>While the benefit of training an MoE/Switch model over its FLOPs matched baseline is clear by now, how does a Switch model compare with a more-FLOPs-demanding dense baseline? The plot below shows that Switch-Base (124B FLOPs/seq) is still more sample efficient than dense T5-Large (425B FLOPs/seq). This is cool!</p><p><img loading=lazy src=sl4.png alt=sl4></p><h2 id=lets-infer-the-tradeoff>Let&rsquo;s &ldquo;infer&rdquo; the tradeoff!<a hidden class=anchor aria-hidden=true href=#lets-infer-the-tradeoff>#</a></h2><p>Now, let&rsquo;s &ldquo;infer&rdquo; a tradeoff from whatever we&rsquo;ve studied till now. I am using those quotes because the tradeoff is regarding the Inference stage. :-)</p><p>The obvious reason being that all the experts need to be loaded
As we&rsquo;ve seen, with the same amount of computational budget, MoE/Switch performs better than the FLOPs matched dense baseline owing to ofcourse, the greater number of parameters that it has. What this also means for the inference stage is that the former requires more memory than the latter in exchange of the performance gains that it offers. The obvious reason being that all the experts need to be loaded in the memory.</p><p>Hence, it&rsquo;s a memory vs performance tradeoff.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] <a href=https://arxiv.org/pdf/2101.03961>Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity</a></p><p>[2] <a href=https://arxiv.org/abs/1701.06538>Outrageously Large Neural Networks: The Sparsely-Gated Mixture-of-Experts Layer</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://srishti-git1110.github.io/tags/nlp-pytorch/>NLP, PyTorch</a></li></ul><nav class=paginav><a class=next href=https://srishti-git1110.github.io/blog/dp/><span class=title>Next »</span><br><span>An Introduction to Differential Privacy</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://srishti-git1110.github.io/>Srishti Gureja</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\[','\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        TeX: { equationNumbers: { autoNumber: "AMS" },
             extensions: ["AMSmath.js", "AMSsymbols.js"] }
      }
    });
    </script><script type=text/x-mathjax-config>
      MathJax.Hub.Queue(function() {
        // Fix <code> tags after MathJax finishes running. This is a
        // hack to overcome a shortcoming of Markdown. Discussion at
        // https://github.com/mojombo/jekyll/issues/199
        var all = MathJax.Hub.getAllJax(), i;
        for(i = 0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script></body></html>